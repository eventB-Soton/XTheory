/*
 * generated by Xtext 2.14.0
 */
package ac.soton.theory.xtext.serializer;

import ac.soton.theory.xtext.services.TheoryGrammarAccess;
import ac.soton.theory.xtext.theory.Argument;
import ac.soton.theory.xtext.theory.Axiom;
import ac.soton.theory.xtext.theory.Case;
import ac.soton.theory.xtext.theory.ConditionalRewrite;
import ac.soton.theory.xtext.theory.ConditionalRewriteRule;
import ac.soton.theory.xtext.theory.Constructor;
import ac.soton.theory.xtext.theory.Destructor;
import ac.soton.theory.xtext.theory.Given;
import ac.soton.theory.xtext.theory.Infer;
import ac.soton.theory.xtext.theory.InferenceRule;
import ac.soton.theory.xtext.theory.Operator;
import ac.soton.theory.xtext.theory.RewriteRule;
import ac.soton.theory.xtext.theory.Rule;
import ac.soton.theory.xtext.theory.Theory;
import ac.soton.theory.xtext.theory.TheoryPackage;
import ac.soton.theory.xtext.theory.Type;
import ac.soton.theory.xtext.theory.UnconditionalRewrite;
import ac.soton.theory.xtext.theory.Variable;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TheorySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TheoryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TheoryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TheoryPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case TheoryPackage.AXIOM:
				sequence_Axiom(context, (Axiom) semanticObject); 
				return; 
			case TheoryPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case TheoryPackage.CONDITIONAL_REWRITE:
				sequence_ConditionalRewrite(context, (ConditionalRewrite) semanticObject); 
				return; 
			case TheoryPackage.CONDITIONAL_REWRITE_RULE:
				sequence_ConditionalRewriteRule(context, (ConditionalRewriteRule) semanticObject); 
				return; 
			case TheoryPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case TheoryPackage.DESTRUCTOR:
				sequence_Destructor(context, (Destructor) semanticObject); 
				return; 
			case TheoryPackage.GIVEN:
				sequence_Given(context, (Given) semanticObject); 
				return; 
			case TheoryPackage.INFER:
				sequence_Infer(context, (Infer) semanticObject); 
				return; 
			case TheoryPackage.INFERENCE_RULE:
				sequence_InferenceRule(context, (InferenceRule) semanticObject); 
				return; 
			case TheoryPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case TheoryPackage.PARAMETER:
				sequence_Parameter(context, (ac.soton.theory.xtext.theory.Parameter) semanticObject); 
				return; 
			case TheoryPackage.REWRITE_RULE:
				sequence_RewriteRule(context, (RewriteRule) semanticObject); 
				return; 
			case TheoryPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case TheoryPackage.THEORY:
				sequence_Theory(context, (Theory) semanticObject); 
				return; 
			case TheoryPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case TheoryPackage.UNCONDITIONAL_REWRITE:
				sequence_UnconditionalRewrite(context, (UnconditionalRewrite) semanticObject); 
				return; 
			case TheoryPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID type=STRING)
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns Axiom
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID predicate=STRING isTheorem?='theorem'?)
	 */
	protected void sequence_Axiom(ISerializationContext context, Axiom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (pattern=STRING formula=STRING)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TheoryPackage.Literals.CASE__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TheoryPackage.Literals.CASE__PATTERN));
			if (transientValues.isValueTransient(semanticObject, TheoryPackage.Literals.CASE__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TheoryPackage.Literals.CASE__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAccess().getPatternSTRINGTerminalRuleCall_0_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getCaseAccess().getFormulaSTRINGTerminalRuleCall_2_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalRewriteRule returns ConditionalRewriteRule
	 *
	 * Constraint:
	 *     (lsh=STRING rhs=STRING)
	 */
	protected void sequence_ConditionalRewriteRule(ISerializationContext context, ConditionalRewriteRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TheoryPackage.Literals.CONDITIONAL_REWRITE_RULE__LSH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TheoryPackage.Literals.CONDITIONAL_REWRITE_RULE__LSH));
			if (transientValues.isValueTransient(semanticObject, TheoryPackage.Literals.CONDITIONAL_REWRITE_RULE__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TheoryPackage.Literals.CONDITIONAL_REWRITE_RULE__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalRewriteRuleAccess().getLshSTRINGTerminalRuleCall_0_0(), semanticObject.getLsh());
		feeder.accept(grammarAccess.getConditionalRewriteRuleAccess().getRhsSTRINGTerminalRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalRewrite returns ConditionalRewrite
	 *
	 * Constraint:
	 *     (rewrites+=ConditionalRewriteRule rewrites+=ConditionalRewriteRule*)
	 */
	protected void sequence_ConditionalRewrite(ISerializationContext context, ConditionalRewrite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID (destructors+=Destructor destructors+=Destructor*)?)
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Destructor returns Destructor
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID type=STRING)
	 */
	protected void sequence_Destructor(ISerializationContext context, Destructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Given returns Given
	 *
	 * Constraint:
	 *     (predicate=STRING required?='required'?)
	 */
	protected void sequence_Given(ISerializationContext context, Given semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Infer returns Infer
	 *
	 * Constraint:
	 *     predicate=STRING
	 */
	protected void sequence_Infer(ISerializationContext context, Infer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TheoryPackage.Literals.INFER__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TheoryPackage.Literals.INFER__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInferAccess().getPredicateSTRINGTerminalRuleCall_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InferenceRule returns InferenceRule
	 *
	 * Constraint:
	 *     (given+=Given* infer=Infer)
	 */
	protected void sequence_InferenceRule(ISerializationContext context, InferenceRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns Operator
	 *
	 * Constraint:
	 *     (
	 *         (comments=ML_COMMENT | comments=SL_COMMENT)? 
	 *         name=ID 
	 *         (arguments+=Argument arguments+=Argument*)? 
	 *         ((type=STRING | notation=Notation)? (associtive?='associative' commutative?='commutative'?)?)+ 
	 *         precedent=INT? 
	 *         wd=STRING? 
	 *         (definition=STRING | (case=ID cases+=Case+))?
	 *     )
	 */
	protected void sequence_Operator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, ac.soton.theory.xtext.theory.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TheoryPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TheoryPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RewriteRule returns RewriteRule
	 *
	 * Constraint:
	 *     (pattern=STRING (rule=UnconditionalRewrite | rule=ConditionalRewrite))
	 */
	protected void sequence_RewriteRule(ISerializationContext context, RewriteRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID (rule=RewriteRule | rule=InferenceRule))
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Theory returns Theory
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameters+=Parameter* 
	 *         (imports+=ID imports+=ID*)? 
	 *         ((types+=Type | operators+=Operator | axioms+=Axiom)? (variables+=Variable* rules+=Rule)?)+
	 *     )
	 */
	protected void sequence_Theory(ISerializationContext context, Theory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID (parameters+=[Parameter|ID]+ constructors+=Constructor constructors+=Constructor*)?)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnconditionalRewrite returns UnconditionalRewrite
	 *
	 * Constraint:
	 *     rhs+=STRING
	 */
	protected void sequence_UnconditionalRewrite(ISerializationContext context, UnconditionalRewrite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     ((comments=ML_COMMENT | comments=SL_COMMENT)? name=ID type=STRING)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
