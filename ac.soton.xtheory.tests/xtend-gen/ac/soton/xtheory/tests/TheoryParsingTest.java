/**
 * generated by Xtext 2.14.0
 */
package ac.soton.xtheory.tests;

import ac.soton.xtheory.internal.common.AssertExtension;
import ac.soton.xtheory.internal.common.AssertTheoryExtension;
import ac.soton.xtheory.tests.TheoryInjectorProvider;
import com.google.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import theoryextension.Theory;

@RunWith(XtextRunner.class)
@InjectWith(TheoryInjectorProvider.class)
@SuppressWarnings("all")
public class TheoryParsingTest {
  @Inject
  @Extension
  private ParseHelper<Theory> parseHelper;
  
  @Extension
  private AssertExtension _assertExtension = new AssertExtension();
  
  @Extension
  private AssertTheoryExtension _assertTheoryExtension = new AssertTheoryExtension();
  
  /**
   * Manually register any EPackage required for running the tests.
   */
  @Before
  public void registerEPackages() {
    this._assertTheoryExtension.registerTheoryEPackage();
  }
  
  /**
   * @Test
   * def void loadModel() {
   * val result = parseHelper.parse('''
   * Hello Xtext!
   * ''')
   * Assert.assertNotNull(result)
   * val errors = result.eResource.errors
   * Assert.assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
   * }
   */
  @Test
  public void testTheoryClauseSuccessful() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      this._assertTheoryExtension.assertTheory(result, "thy", null);
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testParameterClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy(T)");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result, "T");
      this._assertTheoryExtension.assertTheoryInternalElements(result);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testParameterClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy(T S)");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result, "T", "S");
      this._assertTheoryExtension.assertTheoryInternalElements(result);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testTypeClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("type List = nil");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "List = nil");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testTypeClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("type List = nil");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("type Real = zero");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "List = nil", "Real = zero");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus::prefix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op minus");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus::prefix:0:=|", "minus::prefix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testAxiomClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("axm @axm0: \"#x:NAT.x >= 0\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "axm0: #x:NAT.x >= 0");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testAxiomClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("axm @axm0: \"#x:NAT.x >= 0\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("axm @axm1: \"#y:NAT.-y <= 0\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "axm0: #x:NAT.x >= 0", "axm1: #y:NAT.-y <= 0");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testTheoremClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("thm @thm0: \"#x:NAT.x >= 0\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "thm0: #x:NAT.x >= 0");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testTheoremClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("thm @thm0: \"#x:NAT.x >= 0\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("thm @thm1: \"#y:NAT.-y <= 0\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "thm0: #x:NAT.x >= 0", "thm1: #y:NAT.-y <= 0");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @rule0: \"TRUE\" |- \"TRUE\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "rule0: TRUE |- TRUE;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @rule0: \"TRUE\" |- \"TRUE\"");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @rule1: \"FALSE\" |- \"FALSE\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "rule0: TRUE |- TRUE;rule1: FALSE |- FALSE;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testTypeDestructorClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy(T)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("type List = nil | cons(head: \"T\", tail: \"List(T)\")");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result, "T");
      this._assertTheoryExtension.assertTheoryInternalElements(result, "List = nil cons( head: T tail: List(T) )");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorArgumentClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op sqrt(x: \"NAT\")");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "sqrt( x: NAT )::prefix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorArgumentClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y: \"NAT\")");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT )::prefix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorTypeClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y: \"NAT\") : \"NAT\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT ):NAT:prefix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorPrefixClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op sqrt prefix");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "sqrt::prefix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorInfixClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y:\"NAT\") infix");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT )::infix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorPostfixClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op trans(x: \"NAT\") postfix");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "trans( x: NAT )::postfix:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorAssociativeClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y:\"NAT\") associative");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT )::prefix:associative:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorCommutativeClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y:\"NAT\") associative commutative");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT )::prefix:associative:commutative:0:=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorWDClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op sqrt(x: \"INT\") for \"x:NAT\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "sqrt( x: INT )::prefix:0:x:NAT=|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorDefinitionClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y:\"NAT\") = \"x+y\" ");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT )::prefix:0:=x+y|");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorCaseClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op plus(x: \"NAT\", y:\"NAT\") = case x \"INT\" => \"x+y\" ");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "plus( x: NAT y: NAT )::prefix:0:=|x INT => x+y");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testOperatorCaseClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("op listSize(l: \"List(T)\") prefix = case l");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("\"nil\" => \"0\" ");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("\"cons(x, l0)\" => \"1+listSize(l0)\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryInternalElements(result, "listSize( l: List(T) )::prefix:0:=|l nil => 0 cons(x, l0) => 1+listSize(l0)");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockVariableClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("variables x: \"NAT\"");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("rule @rule0: \"TRUE\" |- \"TRUE\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "x: NAT rule0: TRUE |- TRUE;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockVariableClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("variables x: \"NAT\" y: \"NAT\"");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @rule0: \"TRUE\" |- \"TRUE\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "x: NAT y: NAT rule0: TRUE |- TRUE;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockGivenClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @rule0: \"TRUE\" \"FALSE\" |- \"FALSE\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "rule0: TRUE FALSE |- FALSE;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockGivenRequiredClauseSuccessful_1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @rule0: \"TRUE\" required \"FALSE\" |- \"FALSE\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "rule0: TRUE required FALSE |- FALSE;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockUnconditionalClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("variables i: \"INT\" j:\"INT\"");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @CardNatRange: \"card(i..j)\" == \"j-i+1\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "i: INT j: INT CardNatRange: card(i..j) == j-i+1;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRuleBlockConditionalClauseSuccessful_2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("theory thy");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ruleblock");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("variables i: \"INT\" j:\"INT\"");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("rule @CardIntRange: \"card(i..j)\" == \"i<=j\" => \"j-i+1\"");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t   \t\t");
      _builder.append("\"i>j\" => \"0\"");
      _builder.newLine();
      _builder.append("end");
      _builder.newLine();
      final String testInput = _builder.toString();
      final Theory result = this.parseHelper.parse(testInput);
      Assert.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      this._assertExtension.assertEmpty(errors);
      Assert.assertTrue((result instanceof Theory));
      Assert.assertEquals("thy", result.getName());
      this._assertTheoryExtension.assertTheoryParameters(result);
      this._assertTheoryExtension.assertTheoryRuleBlocks(result, "i: INT j: INT CardIntRange: card(i..j) == i<=j => j-i+1 i>j => 0;");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
